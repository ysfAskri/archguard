import type { Finding, AnalysisSummary } from '../core/types.js';
import { logger } from '../utils/logger.js';

interface PrContext {
  owner: string;
  repo: string;
  pullNumber: number;
  token: string;
}

interface ReviewComment {
  path: string;
  line: number;
  body: string;
}

const MAX_REVIEW_COMMENTS = 50;
const GITHUB_API = 'https://api.github.com';

const SEVERITY_ICONS: Record<string, string> = {
  error: ':rotating_light:',
  warning: ':warning:',
  info: ':information_source:',
};

/**
 * Posts findings as inline review comments on a GitHub PR.
 */
export async function postPrReview(
  findings: Finding[],
  prContext: PrContext,
): Promise<void> {
  if (findings.length === 0) return;

  const comments: ReviewComment[] = findings
    .filter(f => f.file && f.line > 0)
    .slice(0, MAX_REVIEW_COMMENTS)
    .map(f => ({
      path: f.file,
      line: f.line,
      body: formatReviewComment(f),
    }));

  if (comments.length === 0) return;

  const body = `**Architecture Guardian** found ${findings.length} issue${findings.length === 1 ? '' : 's'}`;

  try {
    const response = await fetch(
      `${GITHUB_API}/repos/${prContext.owner}/${prContext.repo}/pulls/${prContext.pullNumber}/reviews`,
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${prContext.token}`,
          Accept: 'application/vnd.github+json',
          'Content-Type': 'application/json',
          'X-GitHub-Api-Version': '2022-11-28',
        },
        body: JSON.stringify({
          body,
          event: 'COMMENT',
          comments,
        }),
      },
    );

    if (!response.ok) {
      const text = await response.text();
      logger.warn(`GitHub PR review failed (${response.status}): ${text}`);
    }
  } catch (err) {
    logger.warn(`Failed to post PR review: ${(err as Error).message}`);
  }
}

/**
 * Posts a markdown summary comment on a GitHub PR.
 */
export async function postPrSummary(
  summary: AnalysisSummary,
  prContext: PrContext,
  opts?: { diagram?: string; qualityGatePassed?: boolean },
): Promise<void> {
  const lines: string[] = [];
  lines.push('## :shield: Architecture Guardian Summary\n');

  // Quality gate status
  if (opts?.qualityGatePassed !== undefined) {
    const status = opts.qualityGatePassed ? ':white_check_mark: Passed' : ':x: Failed';
    lines.push(`**Quality Gate:** ${status}\n`);
  }

  // Stats table
  lines.push('| Metric | Count |');
  lines.push('|--------|-------|');
  lines.push(`| Total findings | ${summary.totalFindings} |`);
  lines.push(`| Errors | ${summary.errors} |`);
  lines.push(`| Warnings | ${summary.warnings} |`);
  lines.push(`| Info | ${summary.infos} |`);
  lines.push(`| Files analyzed | ${summary.totalFiles} |`);
  lines.push('');

  // Top issues by analyzer
  if (summary.analyzerResults.length > 0) {
    lines.push('### Top Issues by Analyzer\n');
    for (const result of summary.analyzerResults) {
      if (result.findings.length === 0) continue;
      lines.push(`- **${result.analyzer}**: ${result.findings.length} finding${result.findings.length === 1 ? '' : 's'}`);
    }
    lines.push('');
  }

  // Impact diagram
  if (opts?.diagram) {
    lines.push('<details><summary>Impact Diagram</summary>\n');
    lines.push('```mermaid');
    lines.push(opts.diagram);
    lines.push('```\n');
    lines.push('</details>\n');
  }

  lines.push('---');
  lines.push('*Generated by [Architecture Guardian](https://github.com/archguardian)*');

  const body = lines.join('\n');

  try {
    const response = await fetch(
      `${GITHUB_API}/repos/${prContext.owner}/${prContext.repo}/issues/${prContext.pullNumber}/comments`,
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${prContext.token}`,
          Accept: 'application/vnd.github+json',
          'Content-Type': 'application/json',
          'X-GitHub-Api-Version': '2022-11-28',
        },
        body: JSON.stringify({ body }),
      },
    );

    if (!response.ok) {
      const text = await response.text();
      logger.warn(`GitHub PR comment failed (${response.status}): ${text}`);
    }
  } catch (err) {
    logger.warn(`Failed to post PR summary: ${(err as Error).message}`);
  }
}

function formatReviewComment(finding: Finding): string {
  const icon = SEVERITY_ICONS[finding.severity] ?? '';
  const parts = [`${icon} **[${finding.ruleId}]** ${finding.message}`];
  if (finding.suggestion) {
    parts.push(`\n> **Suggestion:** ${finding.suggestion}`);
  }
  return parts.join('');
}

/**
 * Parses PR context from environment variables (GitHub Actions).
 */
export function parsePrContext(): PrContext | null {
  const token = process.env.GITHUB_TOKEN;
  const repository = process.env.GITHUB_REPOSITORY;
  const prNumber = process.env.GITHUB_PR_NUMBER ??
    process.env.GITHUB_REF?.match(/refs\/pull\/(\d+)/)?.[1];

  if (!token || !repository || !prNumber) return null;

  const [owner, repo] = repository.split('/');
  if (!owner || !repo) return null;

  return {
    owner,
    repo,
    pullNumber: parseInt(prNumber, 10),
    token,
  };
}
